<h3 class="WorkflowDesignerTitleWithCreate">
  {{ labels.Title }}
  <a v-if="!readonly" @click="add()">{{ ButtonTextCreate }}</a>
</h3>
<div id="WorkflowDesignerTimersList" class="WorkflowDesignerWindowForm">
  <table class="WorkflowDesignerTable">
    <tr>
      <th></th>
      <th>{{ labels.Name }}</th>
      <th>{{ labels.Type }}</th>
      <th>{{ labels.Value }}</th>
      <th>
        <el-tooltip :content="labels.OverrideHint" placement="top-start">
          <span style="display: flex">
            <span>{{ labels.Override }}</span>
            <el-icon size="14px" class="header-info-icon">
              <icon-question-filled></icon-question-filled>
            </el-icon>
          </span>
        </el-tooltip>
      </th>
    </tr>
    <tr v-for="(item, index) in items" :key="index"
        :class="dragOverIndex == index && dragOverBlock  == item ? 'dragOver' : ''"
        @dragend="dragend($event)" @dragover="dragover(item, index, $event)"
        @dragstart="dragstart(index, $event)">
      <td :draggable="!readonly" class='WorkflowDesignerTableMoveCol'>
        <div v-if="!readonly" class='WorkflowDesignerTableMoveButton'></div>
      </td>
      <td>
        <el-input
          v-model="item.Name"
          :class="validateField('Name', item) ? 'WorkflowDesignerInputError' : ''"
          :readonly="readonly"
          :title="validateField('Name', item)"
        ></el-input>
      </td>
      <td>
        <el-select
          v-model="item.Type"
          :class="validateField('Type', item) ? 'WorkflowDesignerInputError' : ''"
          :disabled="readonly"
          :title="validateField('Type', item)"
          filterable
          style="width: 100%;"
          @change="item.Value = null">
          <el-option v-for="type in timertypes" :key="type" :label="type" :value="type"></el-option>
        </el-select>
      </td>
      <td>
        <el-input v-if="item.Type == 'Interval'"
                  v-model="item.Value"
                  :class="validateField('Value', item) ? 'WorkflowDesignerInputError' : ''"
                  :readonly="readonly"
                  :title="validateField('Value', item)">
        </el-input>
        <el-time-picker
          v-if="item.Type == 'Time'"
          v-model="item.Value"
          :class="validateField('Value', item) ? 'WorkflowDesignerInputError' : ''"
          :readonly="readonly"
          :title="validateField('Value', item)"
          arrow-control>
        </el-time-picker>
        <el-date-picker
          v-if="item.Type == 'Date'"
          v-model="item.Value"
          :class="validateField('Value', item) ? 'WorkflowDesignerInputError' : ''"
          :readonly="readonly"
          :title="validateField('Value', item)"
          type="date">
        </el-date-picker>
        <el-date-picker
          v-if="item.Type == 'DateAndTime'"
          v-model="item.Value"
          :class="validateField('Value', item) ? 'WorkflowDesignerInputError' : ''"
          :readonly="readonly"
          :title="validateField('Value', item)"
          type="datetime">
        </el-date-picker>
        <el-input v-if="item.Type == 'Expression'"
                  v-model="item.Value"
                  :class="validateField('Value', item) ? 'WorkflowDesignerInputError' : ''"
                  :readonly="readonly"
                  :title="validateField('Value', item)">
        </el-input>
      </td>
      <td>
        <el-checkbox v-model="item.OverrideIfExists" :disabled="readonly"></el-checkbox>
      </td>
      <td v-if="!readonly" style="width: 42px;">
        <el-button class="WorkflowDesignerTableDeleteButton" @click="remove(index)"></el-button>
    </tr>
  </table>
</div>
<div class="WorkflowDesignerButtons">
  <el-button v-if="!readonly" type="primary" @click="onSave">{{ ButtonTextSave }}</el-button>
  <el-button @click="onClose">{{ ButtonTextCancel }}</el-button>
</div>
<script type="application/javascript">
  function timers_Data(me) {
    return {
      readonly: false,
      editItem: undefined,
      timertypes: me.graph.data.AdditionalParams.TimerTypes,

      // TODO initial state, will not work without initial value. check WATCH_ARRAY
      items: []
    }
  }

  function timers_Init(me) {
    const {VueConfig} = me;
    const {state: data, methods} = VueConfig

    methods.UpdateLanguage = function () {
      Object.assign(data, {
        labels: WorkflowDesignerConstants.TimerFormLabel,
        ButtonTextCreate: WorkflowDesignerConstants.ButtonTextCreate,
        ButtonTextDelete: WorkflowDesignerConstants.ButtonTextDelete,
        ButtonTextSave: WorkflowDesignerConstants.ButtonTextSave,
        ButtonTextCancel: WorkflowDesignerConstants.ButtonTextCancel,
      });
    }

    methods.UpdateLanguage();

    methods.onUpdate = function () {
      var clonedTimers = WorkflowDesignerCommon.clone(me.graph.data.Timers);

      clonedTimers.forEach(function (item) {
        item.OverrideIfExists = !item.NotOverrideIfExists;
        switch (item.Type) {
          case 'Time':
            item.Value = moment(item.Value, 'HH:mm:ss').toDate();
            break;
          case 'Date':
            item.Value = moment(item.Value, 'MM/DD/YYYY').toDate();
            break;
          case 'DateAndTime':
            item.Value = moment(item.Value, 'MM/DD/YYYY HH:mm:ss').toDate();
            break;
        }
      });
      data.items = clonedTimers;
      data.readonly = me.graph.Settings.readonly;
    };

    methods.add = function () {
      data.items.push({
        Name: '',
        Type: data.timertypes[0],
        Value: null,
        NotOverrideIfExists: false,
        OverrideIfExists: true
      });

      setTimeout(function () {
        var objDiv = document.getElementById('WorkflowDesignerTimersList');
        objDiv.scrollTop = objDiv.scrollHeight;
      }, 10);
    };

    methods.remove = function (index) {
      data.items.splice(index, 1);
    };

    methods.showjson = function (name, item) {
      data.editItem = item;
      me.editItem = item;
      data.jsonform = me.showjson(item[name], function (value) {
        if (me.editItem) {
          me.editItem[name] = value;
          data.editItem = undefined;
          delete me.editItem;
        }
      })
    };

    methods.validateField = function (name, item) {
      if (name !== 'Name' && name !== 'Type' && name !== 'Value')
        return;

      if (!item[name]) {
        return WorkflowDesignerConstants.FieldIsRequired;
      }

      if (name === 'Value' && (item.Value == null || item.Value == 'Invalid date')) {
        return WorkflowDesignerConstants.FieldIsRequired;
      }

      if (name === 'Value' && item.Type === 'Interval') {
        if (methods.validateCombineValueWithCalendar(item.Value)) {
          return WorkflowDesignerConstants.DoNotCombineCalendars;
        }
        if (methods.validateValueWithCalendar(item.Value)) {
          return WorkflowDesignerConstants.FieldIsNotCorrected;
        }
      }

      if (name === 'Name') {
        var res = data.items.filter(function (i) {
          return i !== item && i.Name === item.Name
        });
        if (res.length > 0) {
          return WorkflowDesignerConstants.FieldMustBeUnique;
        }
      }
    };

    methods.validateCombineValueWithCalendar = function (value) {
      const calendarRegexList = [
        new RegExp(/\d+\s*((wyears)|(wyear)|(wy))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((wmonths)|(wmonth)|(wmm))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((wdays)|(wday)|(wd))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((whours)|(whour)|(wh))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((wminutes)|(wminute)|(wm))(\W|\d|$)/, 'i'),
      ]

      const defaultRegexList = [
        new RegExp(/\d+(\s+|$)/, 'i'),
        new RegExp(/\d+\s*((years)|(year)|(y))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((months)|(month)|(mm))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((days)|(day)|(d))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((hours)|(hour)|(h))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((minutes)|(minute)|(m))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((seconds)|(second)|(s))(\W|\d|$)/, 'i'),
        new RegExp(/\d+\s*((milliseconds)|(millisecond)|(ms))(\W|\d|$)/, 'i'),
      ]

      let isCalendar = false;
      let isDefault = false;
      calendarRegexList.forEach(regex => {
        if (regex.test(value)) {
          isCalendar = true;
        }
      })
      defaultRegexList.forEach(regex => {
        if (regex.test(value)) {
          isDefault = true;
        }
      })

      return isCalendar === isDefault;
    }

    methods.validateValueWithCalendar = function (value) {
      const calendarRegexList = [
        new RegExp(/\d+\s*((wyears)|(wyear)|(wy))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((wmonths)|(wmonth)|(wmm))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((wdays)|(wday)|(wd))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((whours)|(whour)|(wh))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((wminutes)|(wminute)|(wm))(\s*$)/, 'i'),
      ]
      const defaultRegexList = [
        new RegExp(/\d+(?!\w+)(\s*$)/, 'i'),
        new RegExp(/\d+\s*((years)|(year)|(y))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((months)|(month)|(mm))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((days)|(day)|(d))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((hours)|(hour)|(h))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((minutes)|(minute)|(m))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((seconds)|(second)|(s))(\s*$)/, 'i'),
        new RegExp(/\d+\s*((milliseconds)|(millisecond)|(ms))(\s*$)/, 'i')
      ]
      let isCalendar = false;
      let isDefault = false;
      calendarRegexList.forEach(regex => {
        if (regex.test(value)) {
          isCalendar = true;
        }
      })
      defaultRegexList.forEach(regex => {
        if (regex.test(value)) {
          isDefault = true;
        }
      })

      return isCalendar === isDefault;
    }

    methods.validate = function () {
      var validateFunc = methods.validateField;
      var items = data.items;
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (validateFunc('Name', item) || item.Value == null)
          return false;
        if (validateFunc('Value', item))
          return false;
      }
      return true;
    };

    methods.onSave = function () {
      if (methods.validate && methods.validate()) {
        const newItems = data.items.map((i) => {
          return {
            Name: i.Name,
            NotOverrideIfExists: !i.OverrideIfExists,
            Type: i.Type,
            Value: methods.convertValue(i)
          };
        })
        me.graph.UpdateData(me.graph.data.Timers, newItems);
        me.onClose(true);
      }
    };

    methods.convertValue = function (item) {
      switch (item.Type) {
        case 'Time':
          return moment(item.Value).format('HH:mm:ss');
        case 'Date':
          return moment(item.Value).format('MM/DD/YYYY');
        case 'DateAndTime':
          return moment(item.Value).format('MM/DD/YYYY HH:mm:ss');
        default:
          return item.Value;
      }
    }

    methods.onClose = function () {

      if (data.readonly) {
        me.onClose(true);
        return;
      }
      const newItems = data.items.map((i) => {
        return {
          Name: i.Name,
          NotOverrideIfExists: !i.OverrideIfExists,
          Type: i.Type,
          Value: methods.convertValue(i)
        };
      })

      if (WorkflowDesignerCommon.compareArray(
        me.graph.data.Timers,
        newItems,
        ['Name', 'Type', 'Value', 'NotOverrideIfExists'])) {

        me.onClose(true);
      } else {
        me.showConfirm();
      }
    };

    methods.onCloseSave = function () {
      me.onClose(true);
    };

    me.showConfirm = function () {
      methods.showConfirm({
        title: WorkflowDesignerConstants.DialogConfirmText,
        message: WorkflowDesignerConstants.CloseWithoutSaving,
        onSuccess: function () {
          methods.onCloseSave();
        }
      });
    }
  }
</script>
